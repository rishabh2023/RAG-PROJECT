**COMPREHENSIVE REPLIT PROMPT: AI LOAN SUPPORT BACKEND**

Create a complete AI Customer Support backend for a loan company with the following specifications:

## PROJECT REQUIREMENTS

Build a FastAPI-based backend that serves as an AI assistant for home loan queries. The system should:
- Answer borrower questions with citations from documents
- Calculate loan eligibility quickly
- Handle state-specific queries (focus on Karnataka)
- Mask PII data (PAN/Aadhaar)
- Support multiple channels (web chat, voice, WhatsApp) through unified APIs
- Use MCP server for tool orchestration
- Integrate with Pinecone vector DB and Gemini LLM

## FOLDER STRUCTURE

```
loan_support_backend/
├── app/
│   ├── __init__.py
│   ├── main.py                    # FastAPI app entry point
│   ├── config.py                  # Configuration settings
│   ├── models/
│   │   ├── __init__.py
│   │   ├── request_models.py      # Pydantic request models
│   │   └── response_models.py     # Pydantic response models
│   ├── api/
│   │   ├── __init__.py
│   │   ├── endpoints/
│   │   │   ├── __init__.py
│   │   │   ├── chat.py           # Chat endpoint
│   │   │   ├── eligibility.py    # Eligibility calculation
│   │   │   ├── feedback.py       # Feedback collection
│   │   │   └── health.py         # Health check
│   │   └── dependencies.py       # FastAPI dependencies
│   ├── core/
│   │   ├── __init__.py
│   │   ├── mcp_server.py         # MCP server implementation
│   │   ├── rag_engine.py         # RAG retrieval engine
│   │   ├── llm_client.py         # Gemini LLM client
│   │   ├── security.py           # PII redaction & auth
│   │   └── metrics.py            # Performance metrics
│   ├── tools/
│   │   ├── __init__.py
│   │   ├── retrieval_tool.py     # Document retrieval
│   │   ├── eligibility_tool.py   # Loan eligibility calculator
│   │   ├── policy_tool.py        # Policy lookup
│   │   └── escalation_tool.py    # Human escalation
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── document_processor.py # PDF processing
│   │   ├── state_mapper.py       # State-specific logic
│   │   └── validators.py         # Input validation
│   └── data/
│       ├── documents/
│       │   ├── karnataka_salaried_docs.pdf
│       │   ├── karnataka_stamp_duty.pdf
│       │   ├── loan_glossary.pdf
│       │   └── general_loan_guide.pdf
│       └── embeddings/            # Local FAISS index
├── tests/
│   ├── __init__.py
│   ├── test_chat.py              # Chat API tests
│   ├── test_eligibility.py       # Eligibility tests
│   ├── test_security.py          # PII redaction tests
│   ├── test_mcp_tools.py         # MCP tools tests
│   └── test_integration.py       # End-to-end tests
├── requirements.txt
├── .env.example
├── postman_collection.json
└── README.md
```

## IMPLEMENTATION

### 1. Create requirements.txt
```
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
python-multipart==0.0.6
google-generativeai==0.3.2
pinecone-client==2.2.4
faiss-cpu==1.7.4
PyPDF2==3.0.1
numpy==1.24.3
sentence-transformers==2.2.2
python-dotenv==1.0.0
pytest==7.4.3
pytest-asyncio==0.21.1
httpx==0.25.2
mcp==1.0.0
redis==5.0.1
```

### 2. Create .env.example
```
GEMINI_API_KEY=your_gemini_api_key_here
PINECONE_API_KEY=your_pinecone_api_key_here
PINECONE_INDEX_NAME=loan-support-v1
PINECONE_ENVIRONMENT=us-west1-gcp-free
BEARER_TOKEN=your_secure_bearer_token
REDIS_URL=redis://localhost:6379
USE_LOCAL_FAISS=true
LOG_LEVEL=INFO
```

### 3. Create app/config.py
```python
from pydantic_settings import BaseSettings
from typing import Optional
import os

class Settings(BaseSettings):
    # API Configuration
    API_VERSION: str = "v1"
    API_PREFIX: str = f"/api/{API_VERSION}"
    PROJECT_NAME: str = "AI Loan Support Backend"
    
    # LLM Configuration
    GEMINI_API_KEY: str
    GEMINI_MODEL: str = "gemini-1.5-flash"
    
    # Vector DB Configuration
    PINECONE_API_KEY: Optional[str] = None
    PINECONE_INDEX_NAME: str = "loan-support-v1"
    PINECONE_ENVIRONMENT: str = "us-west1-gcp-free"
    USE_LOCAL_FAISS: bool = True
    
    # Security
    BEARER_TOKEN: str = "dev-token-change-in-production"
    RATE_LIMIT_REQUESTS: int = 100
    RATE_LIMIT_WINDOW: int = 3600  # 1 hour
    
    # Performance
    MAX_RETRIEVAL_DOCS: int = 5
    RETRIEVAL_TIMEOUT: float = 1.2
    LLM_TIMEOUT: float = 3.5
    
    # PII Redaction
    MASK_PAN: bool = True
    MASK_AADHAAR: bool = True
    
    class Config:
        env_file = ".env"

settings = Settings()
```

### 4. Create app/models/request_models.py
```python
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
from enum import Enum

class MessageRole(str, Enum):
    USER = "user"
    ASSISTANT = "assistant"

class ChatMessage(BaseModel):
    role: MessageRole
    content: str
    timestamp: Optional[str] = None

class ChatRequest(BaseModel):
    message: str = Field(..., min_length=1, max_length=2000)
    context: Optional[Dict[str, Any]] = Field(default_factory=dict)
    session_id: Optional[str] = None
    state: Optional[str] = None
    city: Optional[str] = None
    user_type: Optional[str] = Field(None, description="salaried, self_employed, etc.")

class EligibilityRequest(BaseModel):
    monthly_income: float = Field(..., gt=0, description="Monthly income in INR")
    existing_obligations: float = Field(0, ge=0, description="Existing EMIs in INR")
    interest_rate: float = Field(..., gt=0, le=30, description="Interest rate percentage")
    tenure_years: int = Field(..., gt=0, le=30, description="Loan tenure in years")
    foir_cap: Optional[float] = Field(40.0, gt=0, le=100, description="FOIR cap percentage")

class FeedbackRequest(BaseModel):
    session_id: str
    rating: int = Field(..., ge=1, le=5)
    comment: Optional[str] = Field(None, max_length=500)
    category: Optional[str] = Field(None, description="helpful, accurate, fast, etc.")
```

### 5. Create app/models/response_models.py
```python
from pydantic import BaseModel
from typing import List, Optional, Dict, Any

class Citation(BaseModel):
    id: str
    title: str
    content: str
    source: str
    confidence: float

class ChatResponse(BaseModel):
    response: str
    citations: List[Citation]
    next_steps: List[str]
    confidence: float
    should_escalate: bool
    session_id: str
    processing_time_ms: float

class EligibilityResponse(BaseModel):
    max_emi: float
    estimated_loan_amount: float
    foir_used: float
    monthly_surplus: float
    eligibility_status: str
    disclaimer: str

class FeedbackResponse(BaseModel):
    success: bool
    message: str

class HealthResponse(BaseModel):
    status: str
    version: str
    dependencies: Dict[str, str]
    uptime_seconds: float
```

### 6. Create app/core/security.py
```python
import re
import hashlib
from typing import str

class PIIRedactor:
    def __init__(self):
        # PAN pattern: 5 letters + 4 digits + 1 letter
        self.pan_pattern = re.compile(r'\b[A-Z]{5}[0-9]{4}[A-Z]{1}\b')
        # Aadhaar pattern: 12 digits (with/without spaces/hyphens)
        self.aadhaar_pattern = re.compile(r'\b\d{4}[-\s]?\d{4}[-\s]?\d{4}\b')
    
    def redact_text(self, text: str) -> str:
        """Redact PII from text"""
        # Redact PAN
        text = self.pan_pattern.sub(lambda m: m.group()[:6] + 'X' * 4, text)
        
        # Redact Aadhaar
        text = self.aadhaar_pattern.sub(
            lambda m: re.sub(r'\d', 'X', m.group()[4:-4]) if len(m.group().replace('-', '').replace(' ', '')) == 12 
            else m.group(), text
        )
        
        return text
    
    def contains_pii(self, text: str) -> bool:
        """Check if text contains PII"""
        return bool(self.pan_pattern.search(text) or self.aadhaar_pattern.search(text))

def verify_bearer_token(token: str) -> bool:
    """Verify bearer token"""
    from app.config import settings
    return token == settings.BEARER_TOKEN

redactor = PIIRedactor()
```

### 7. Create app/core/llm_client.py
```python
import google.generativeai as genai
from typing import List, Dict, Any
import asyncio
import time
from app.config import settings
from app.core.security import redactor

class GeminiClient:
    def __init__(self):
        genai.configure(api_key=settings.GEMINI_API_KEY)
        self.model = genai.GenerativeModel(settings.GEMINI_MODEL)
        
    async def generate_response(
        self, 
        query: str, 
        context_docs: List[Dict[str, Any]] = None,
        system_prompt: str = None
    ) -> Dict[str, Any]:
        """Generate response with citations"""
        
        start_time = time.time()
        
        # Build prompt with context
        prompt = self._build_prompt(query, context_docs, system_prompt)
        
        try:
            response = await asyncio.wait_for(
                self._generate_async(prompt),
                timeout=settings.LLM_TIMEOUT
            )
            
            # Redact PII from response
            clean_response = redactor.redact_text(response)
            
            processing_time = (time.time() - start_time) * 1000
            
            return {
                "response": clean_response,
                "processing_time_ms": processing_time,
                "success": True
            }
            
        except asyncio.TimeoutError:
            return {
                "response": "I'm experiencing high load. Please try again in a moment.",
                "processing_time_ms": settings.LLM_TIMEOUT * 1000,
                "success": False
            }
    
    def _build_prompt(self, query: str, context_docs: List[Dict], system_prompt: str = None) -> str:
        """Build prompt with context and citations"""
        
        base_prompt = system_prompt or """You are an AI assistant for a home loan company in India. 
Provide helpful, accurate information about home loans, documentation, and eligibility.

IMPORTANT RULES:
1. Always cite sources using [1], [2] format when using provided documents
2. Never hallucinate policy details or specific rates
3. If uncertain, say so and suggest speaking with an advisor
4. Focus on being helpful while staying within your knowledge
5. Provide 1-3 concrete next steps at the end
6. Keep responses concise but complete"""

        if context_docs:
            context_text = "\n\nRELEVANT DOCUMENTS:\n"
            for i, doc in enumerate(context_docs, 1):
                context_text += f"[{i}] {doc.get('title', 'Document')}: {doc.get('content', '')}\n"
            prompt = f"{base_prompt}\n{context_text}\n\nQUERY: {query}\n\nRESPONSE:"
        else:
            prompt = f"{base_prompt}\n\nQUERY: {query}\n\nRESPONSE:"
            
        return prompt
    
    async def _generate_async(self, prompt: str) -> str:
        """Async wrapper for generation"""
        response = self.model.generate_content(prompt)
        return response.text

llm_client = GeminiClient()
```

### 8. Create app/core/rag_engine.py
```python
import numpy as np
import faiss
import pickle
import os
from typing import List, Dict, Any, Optional
from sentence_transformers import SentenceTransformer
from app.config import settings
import pinecone

class RAGEngine:
    def __init__(self):
        self.encoder = SentenceTransformer('all-MiniLM-L6-v2')
        self.local_index = None
        self.documents = []
        self.pinecone_index = None
        
        # Initialize Pinecone if configured
        if settings.PINECONE_API_KEY and not settings.USE_LOCAL_FAISS:
            self._init_pinecone()
        else:
            self._init_local_faiss()
    
    def _init_pinecone(self):
        """Initialize Pinecone connection"""
        try:
            pinecone.init(
                api_key=settings.PINECONE_API_KEY,
                environment=settings.PINECONE_ENVIRONMENT
            )
            self.pinecone_index = pinecone.Index(settings.PINECONE_INDEX_NAME)
        except Exception as e:
            print(f"Pinecone init failed, falling back to local FAISS: {e}")
            self._init_local_faiss()
    
    def _init_local_faiss(self):
        """Initialize local FAISS index"""
        try:
            # Load pre-built index if exists
            index_path = "app/data/embeddings/faiss_index.bin"
            docs_path = "app/data/embeddings/documents.pkl"
            
            if os.path.exists(index_path) and os.path.exists(docs_path):
                self.local_index = faiss.read_index(index_path)
                with open(docs_path, 'rb') as f:
                    self.documents = pickle.load(f)
            else:
                # Create new index with sample data
                self._create_sample_index()
        except Exception as e:
            print(f"FAISS init failed: {e}")
            self._create_sample_index()
    
    def _create_sample_index(self):
        """Create sample FAISS index with loan documents"""
        sample_docs = [
            {
                "id": "ka_salaried_docs",
                "title": "Karnataka Salaried Documents Checklist",
                "content": "For salaried home loan applicants in Karnataka: 1) Identity Proof: PAN Card, Aadhaar Card, Passport 2) Address Proof: Aadhaar, Utility Bills, Rent Agreement 3) Income Proof: Salary slips (3 months), Bank statements (6 months), Form 16, Employment letter 4) Property Documents: Sale agreement, Property card, Khata extract, Encumbrance certificate 5) Other: Photographs, Processing fee cheque",
                "source": "Karnataka Banking Guide 2024",
                "jurisdiction": "Karnataka",
                "category": "documentation"
            },
            {
                "id": "ka_stamp_duty",
                "title": "Karnataka Stamp Duty and Registration",
                "content": "Karnataka stamp duty for residential properties: 5% for properties above Rs 45 lakhs in BBMP limits, 3% for properties below Rs 45 lakhs. Registration charges: 1% of property value. Additional charges: Survey settlement fee, conversion fee if applicable. Total cost approximately 6% of property value in Bangalore.",
                "source": "Karnataka Revenue Department 2024",
                "jurisdiction": "Karnataka",
                "category": "stamp_duty"
            },
            {
                "id": "eligibility_basics",
                "title": "Home Loan Eligibility Basics",
                "content": "Home loan eligibility factors: 1) FOIR (Fixed Obligation to Income Ratio) should be below 40-50% 2) Minimum income: Rs 25,000 for salaried, Rs 2 lakhs annual for self-employed 3) Age: 21-65 years 4) Employment stability: 2+ years experience 5) Credit score: 750+ preferred 6) LTV ratio: Up to 80-90% of property value",
                "source": "RBI Guidelines & Banking Practices",
                "jurisdiction": "India",
                "category": "eligibility"
            },
            {
                "id": "loan_glossary",
                "title": "Loan Terms Glossary",
                "content": "Key loan terms: EMI (Equated Monthly Installment) - fixed monthly payment. FOIR (Fixed Obligation to Income Ratio) - percentage of income going to debt payments. LTV (Loan to Value) - loan amount as percentage of property value. Processing fee - upfront bank charges. Prepayment - paying loan amount before tenure completion. Sanction - loan approval. Disbursal - actual fund transfer.",
                "source": "Banking Terminology Guide",
                "jurisdiction": "India",
                "category": "glossary"
            }
        ]
        
        # Create embeddings
        texts = [doc["content"] for doc in sample_docs]
        embeddings = self.encoder.encode(texts)
        
        # Create FAISS index
        dimension = embeddings.shape[1]
        self.local_index = faiss.IndexFlatIP(dimension)
        self.local_index.add(embeddings.astype('float32'))
        self.documents = sample_docs
        
        # Save index
        os.makedirs("app/data/embeddings", exist_ok=True)
        faiss.write_index(self.local_index, "app/data/embeddings/faiss_index.bin")
        with open("app/data/embeddings/documents.pkl", 'wb') as f:
            pickle.dump(self.documents, f)
    
    async def retrieve_documents(
        self, 
        query: str, 
        k: int = 5, 
        filters: Dict[str, Any] = None
    ) -> List[Dict[str, Any]]:
        """Retrieve relevant documents"""
        
        if self.pinecone_index:
            return await self._retrieve_pinecone(query, k, filters)
        else:
            return await self._retrieve_faiss(query, k, filters)
    
    async def _retrieve_faiss(self, query: str, k: int, filters: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Retrieve from local FAISS"""
        if not self.local_index or not self.documents:
            return []
        
        # Encode query
        query_embedding = self.encoder.encode([query])
        
        # Search
        scores, indices = self.local_index.search(query_embedding.astype('float32'), k)
        
        results = []
        for i, (score, idx) in enumerate(zip(scores[0], indices[0])):
            if idx < len(self.documents):
                doc = self.documents[idx].copy()
                doc["confidence"] = float(score)
                
                # Apply filters
                if filters:
                    if filters.get("jurisdiction") and doc.get("jurisdiction") != filters["jurisdiction"]:
                        continue
                    if filters.get("category") and doc.get("category") != filters["category"]:
                        continue
                
                results.append(doc)
        
        return results[:k]
    
    async def _retrieve_pinecone(self, query: str, k: int, filters: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Retrieve from Pinecone"""
        # Implement Pinecone retrieval
        query_embedding = self.encoder.encode([query])
        
        # Query Pinecone
        response = self.pinecone_index.query(
            vector=query_embedding[0].tolist(),
            top_k=k,
            filter=filters or {},
            include_metadata=True
        )
        
        results = []
        for match in response.matches:
            doc = {
                "id": match.id,
                "confidence": match.score,
                **match.metadata
            }
            results.append(doc)
        
        return results

rag_engine = RAGEngine()
```

### 9. Create app/tools/eligibility_tool.py
```python
import math
from typing import Dict, Any

class EligibilityCalculator:
    """Calculate home loan eligibility based on income and obligations"""
    
    @staticmethod
    def calculate_eligibility(
        monthly_income: float,
        existing_obligations: float,
        interest_rate: float,
        tenure_years: int,
        foir_cap: float = 40.0
    ) -> Dict[str, Any]:
        """
        Calculate loan eligibility using FOIR method
        
        Returns:
            - max_emi: Maximum EMI user can afford
            - estimated_loan_amount: Estimated loan amount
            - foir_used: FOIR percentage used
            - monthly_surplus: Remaining monthly income
        """
        
        # Calculate maximum EMI based on FOIR
        max_emi_by_foir = (monthly_income * foir_cap / 100) - existing_obligations
        
        if max_emi_by_foir <= 0:
            return {
                "max_emi": 0,
                "estimated_loan_amount": 0,
                "foir_used": (existing_obligations / monthly_income) * 100,
                "monthly_surplus": monthly_income - existing_obligations,
                "eligibility_status": "Not Eligible - Existing obligations too high",
                "disclaimer": "Current obligations exceed income capacity. Consider reducing existing EMIs."
            }
        
        # Calculate loan amount using EMI formula
        # EMI = P * r * (1+r)^n / ((1+r)^n - 1)
        # Rearranging: P = EMI * ((1+r)^n - 1) / (r * (1+r)^n)
        
        monthly_rate = interest_rate / (12 * 100)
        total_months = tenure_years * 12
        
        if monthly_rate == 0:
            # If interest rate is 0, simple calculation
            estimated_loan_amount = max_emi_by_foir * total_months
        else:
            # Standard EMI calculation
            denominator = monthly_rate * ((1 + monthly_rate) ** total_months)
            numerator = ((1 + monthly_rate) ** total_months) - 1
            estimated_loan_amount = max_emi_by_foir * (numerator / denominator)
        
        foir_used = ((existing_obligations + max_emi_by_foir) / monthly_income) * 100
        monthly_surplus = monthly_income - existing_obligations - max_emi_by_foir
        
        # Determine eligibility status
        if estimated_loan_amount >= 500000:  # Minimum loan amount
            status = "Eligible"
        elif estimated_loan_amount >= 200000:
            status = "Conditionally Eligible"
        else:
            status = "Low Eligibility"
        
        return {
            "max_emi": round(max_emi_by_foir, 2),
            "estimated_loan_amount": round(estimated_loan_amount, 2),
            "foir_used": round(foir_used, 2),
            "monthly_surplus": round(monthly_surplus, 2),
            "eligibility_status": status,
            "disclaimer": "This is an indicative calculation. Final approval depends on credit score, property valuation, and bank policies."
        }

eligibility_calculator = EligibilityCalculator()
```

### 10. Create app/core/mcp_server.py
```python
import asyncio
import time
from typing import Dict, Any, List, Optional
from app.core.rag_engine import rag_engine
from app.tools.eligibility_tool import eligibility_calculator
from app.core.llm_client import llm_client

class MCPServer:
    """Model Context Protocol server for tool orchestration"""
    
    def __init__(self):
        self.tools = {
            "retrieve_docs": self.retrieve_docs,
            "compute_eligibility": self.compute_eligibility,
            "policy_lookup": self.policy_lookup,
            "escalate_to_human": self.escalate_to_human
        }
    
    async def execute_tool(self, tool_name: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a specific tool"""
        if tool_name not in self.tools:
            return {"error": f"Unknown tool: {tool_name}"}
        
        try:
            result = await self.tools[tool_name](**parameters)
            return {"success": True, "result": result}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def retrieve_docs(
        self, 
        query: str, 
        k: int = 5, 
        filters: Optional[Dict[str, Any]] = None
    ) -> List[Dict[str, Any]]:
        """Retrieve relevant documents using RAG"""
        start_time = time.time()
        
        docs = await rag_engine.retrieve_documents(query, k, filters)
        
        retrieval_time = (time.time() - start_time) * 1000
        
        return {
            "documents": docs,
            "retrieval_time_ms": retrieval_time,
            "query": query
        }
    
    async def compute_eligibility(
        self,
        monthly_income: float,
        existing_obligations: float = 0,
        interest_rate: float = 8.5,
        tenure_years: int = 20,
        foir_cap: float = 40.0
    ) -> Dict[str, Any]:
        """Calculate loan eligibility"""
        
        result = eligibility_calculator.calculate_eligibility(
            monthly_income=monthly_income,
            existing_obligations=existing_obligations,
            interest_rate=interest_rate,
            tenure_years=tenure_years,
            foir_cap=foir_cap
        )
        
        return result
    
    async def policy_lookup(
        self,
        state: str,
        topic: str,
        query: str = ""
    ) -> Dict[str, Any]:
        """Look up state-specific policies"""
        
        # Create targeted filters for state-specific content
        filters = {
            "jurisdiction": state,
            "category": topic
        }
        
        search_query = f"{topic} {state} {query}" if query else f"{topic} {state}"
        
        docs = await rag_engine.retrieve_documents(search_query, k=3, filters=filters)
        
        return {
            "state": state,
            "topic": topic,
            "documents": docs,
            "query": search_query
        }
    
    async def escalate_to_human(self, session_id: str, reason: str = "") -> Dict[str, Any]:
        """Escalate conversation to human advisor"""
        
        # In POC, this is a stub. In production, this would:
        # - Create a ticket in CRM
        # - Notify available advisors
        # - Transfer context
        
        return {
            "escalated": True,
            "session_id": session_id,
            "reason": reason,
            "estimated_wait_time": "2-5 minutes",
            "ticket_id": f"LOAN_{session_id}_{int(time.time())}"
        }
    
    async def process_chat_query(
        self,
        query: str,
        context: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """Process a chat query using appropriate tools"""
        
        context = context or {}
        session_id = context.get("session_id", f"session_{int(time.time())}")
        
        # Determine which tools to use based on query
        tools_to_use = self._determine_tools(query, context)
        
        # Execute tools
        tool_results = {}
        for tool_name, params in tools_to_use.items():
            result = await self.execute_tool(tool_name, params)
            tool_results[tool_name] = result
        
        # Generate response using LLM
        llm_result = await self._generate_response(query, tool_results, context)
        
        return {
            "session_id": session_id,
            "query": query,
            "tool_results": tool_results,
            "llm_response": llm_result,
            "processing_time_ms": sum([
                tool_results.get("retrieve_docs", {}).get("result", {}).get("retrieval_time_ms", 0),
                llm_result.get("processing_time_ms", 0)
            ])
        }
    
    def _determine_tools(self, query: str, context: Dict[str, Any]) -> Dict[str, Dict[str, Any]]:
        """Determine which tools to use based on query"""
        tools = {}
        
        query_lower = query.lower()
        
        # Check for eligibility calculation keywords
        if any(word in query_lower for word in ["eligible", "eligibility", "loan amount", "emi", "afford"]):
            # Try to extract numbers from context or query
            tools["compute_eligibility"] = {
                "monthly_income": context.get("monthly_income", 100000),  # Default for demo
                "existing_obligations": context.get("existing_obligations", 0),
                "interest_rate": context.get("interest_rate", 8.5),
                "tenure_years": context.get("tenure_years", 20)
            }
        
        # Check for state-specific queries
        state = context.get("state") or self._extract_state(query)
        if state:
            topic = self._extract_topic(query)
            tools["policy_lookup"] = {
                "state": state,
                "topic": topic,
                "query": query
            }
        
        # Always do document retrieval for informational queries
        if not tools or any(word in query_lower for word in ["document", "need", "require", "process", "how"]):
            filters = {}
            if state:
                filters["jurisdiction"] = state
            
            tools["retrieve_docs"] = {
                "query": query,
                "k": 5,
                "filters": filters
            }
        
        return tools
    
    def _extract_state(self, query: str) -> Optional[str]:
        """Extract state from query"""
        query_lower = query.lower()
        
        state_mapping = {
            "karnataka": "Karnataka",
            "bangalore": "Karnataka",
            "bengaluru": "Karnataka",
            "mysore": "Karnataka",
            "hubli": "Karnataka"
        }
        
        for keyword, state in state_mapping.items():
            if keyword in query_lower:
                return state
        
        return None
    
    def _extract_topic(self, query: str) -> str:
        """Extract topic from query"""
        query_lower = query.lower()
        
        if any(word in query_lower for word in ["document", "papers", "requirement"]):
            return "documentation"
        elif any(word in query_lower for word in ["stamp duty", "registration", "fee"]):
            return "stamp_duty"
        elif any(word in query_lower for word in ["eligible", "eligibility"]):
            return "eligibility"
        else:
            return "general"
    
    async def _generate_response(
        self,
        query: str,
        tool_results: Dict[str, Any],
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate LLM response using tool results"""
        
        # Prepare context documents
        context_docs = []
        citations = []
        
        # Extract documents from retrieval results
        if "retrieve_docs" in tool_results and tool_results["retrieve_docs"]["success"]:
            docs = tool_results["retrieve_docs"]["result"]["documents"]
            for i, doc in enumerate(docs):
                context_docs.append(doc)
                citations.append({
                    "id": str(i + 1),
                    "title": doc.get("title", "Document"),
                    "content": doc.get("content", "")[:200] + "...",
                    "source": doc.get("source", "Internal Document"),
                    "confidence": doc.get("confidence", 0.0)
                })
        
        # Include eligibility results in context
        eligibility_info = ""
        if "compute_eligibility" in tool_results and tool_results["compute_eligibility"]["success"]:
            elig = tool_results["compute_eligibility"]["result"]
            eligibility_info = f"\nELIGIBILITY CALCULATION:\n"
            eligibility_info += f"Max EMI: ₹{elig['max_emi']:,.0f}\n"
            eligibility_info += f"Estimated Loan Amount: ₹{elig['estimated_loan_amount']:,.0f}\n"
            eligibility_info += f"FOIR Used: {elig['foir_used']:.1f}%\n"
            eligibility_info += f"Status: {elig['eligibility_status']}\n"
        
        # Build system prompt
        system_prompt = f"""You are an AI assistant for a home loan company in India.
Provide helpful, accurate information about home loans.

CONTEXT INFO:
- User location: {context.get('state', 'India')} {context.get('city', '')}
- User type: {context.get('user_type', 'general')}
{eligibility_info}

IMPORTANT RULES:
1. Cite sources using [1], [2] format when using provided documents
2. Provide specific, actionable information
3. If eligibility was calculated, include the key numbers
4. Give 2-3 concrete next steps
5. Keep response concise but helpful
6. Never hallucinate specific rates or policies"""

        # Generate response
        llm_result = await llm_client.generate_response(
            query=query,
            context_docs=context_docs,
            system_prompt=system_prompt
        )
        
        # Determine if escalation is needed
        should_escalate = self._should_escalate(query, tool_results, llm_result)
        
        # Extract next steps (in a real implementation, this would be more sophisticated)
        next_steps = self._extract_next_steps(query, tool_results)
        
        return {
            "response": llm_result["response"],
            "citations": citations,
            "next_steps": next_steps,
            "should_escalate": should_escalate,
            "confidence": self._calculate_confidence(tool_results),
            "processing_time_ms": llm_result["processing_time_ms"]
        }
    
    def _should_escalate(self, query: str, tool_results: Dict, llm_result: Dict) -> bool:
        """Determine if query should be escalated to human"""
        
        # Escalate if low confidence
        if self._calculate_confidence(tool_results) < 0.3:
            return True
        
        # Escalate for complex legal/financial questions
        escalation_keywords = [
            "guarantee", "legal advice", "tax implication", 
            "dispute", "complaint", "refund", "cancel"
        ]
        
        if any(keyword in query.lower() for keyword in escalation_keywords):
            return True
        
        return False
    
    def _calculate_confidence(self, tool_results: Dict) -> float:
        """Calculate overall confidence score"""
        
        confidences = []
        
        # Document retrieval confidence
        if "retrieve_docs" in tool_results and tool_results["retrieve_docs"]["success"]:
            docs = tool_results["retrieve_docs"]["result"]["documents"]
            if docs:
                avg_confidence = sum(doc.get("confidence", 0) for doc in docs) / len(docs)
                confidences.append(avg_confidence)
        
        # Eligibility calculation always has high confidence
        if "compute_eligibility" in tool_results and tool_results["compute_eligibility"]["success"]:
            confidences.append(0.95)
        
        if confidences:
            return sum(confidences) / len(confidences)
        else:
            return 0.5  # Neutral confidence
    
    def _extract_next_steps(self, query: str, tool_results: Dict) -> List[str]:
        """Extract relevant next steps"""
        
        steps = []
        query_lower = query.lower()
        
        if "document" in query_lower:
            steps.append("Gather the required documents mentioned above")
            steps.append("Visit your nearest bank branch or apply online")
        
        if any(word in query_lower for word in ["eligible", "afford", "loan amount"]):
            steps.append("Use our eligibility calculator with your exact income details")
            steps.append("Check your credit score (aim for 750+)")
        
        if "stamp duty" in query_lower:
            steps.append("Calculate exact stamp duty based on your property value")
            steps.append("Budget for additional registration and legal charges")
        
        if not steps:
            steps = [
                "Speak with our loan advisor for personalized guidance",
                "Check current interest rates and offers",
                "Prepare your financial documents"
            ]
        
        return steps[:3]  # Return max 3 steps

mcp_server = MCPServer()
```

### 11. Create app/api/endpoints/chat.py
```python
from fastapi import APIRouter, HTTPException, Depends, Header
from typing import Optional
import time
import uuid

from app.models.request_models import ChatRequest
from app.models.response_models import ChatResponse
from app.core.mcp_server import mcp_server
from app.core.security import redactor, verify_bearer_token

router = APIRouter()

def get_bearer_token(authorization: Optional[str] = Header(None)) -> str:
    """Extract and verify bearer token"""
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Bearer token required")
    
    token = authorization.split(" ")[1]
    if not verify_bearer_token(token):
        raise HTTPException(status_code=401, detail="Invalid token")
    
    return token

@router.post("/chat", response_model=ChatResponse)
async def chat_endpoint(
    request: ChatRequest,
    token: str = Depends(get_bearer_token)
):
    """
    Main chat endpoint for loan support queries
    
    Example queries:
    - "What documents do I need for a ₹75L home loan in Bengaluru? I'm salaried."
    - "Am I eligible for a home loan with ₹1,20,000 monthly income?"
    - "What's the stamp duty for an ₹85L property in Karnataka?"
    """
    
    start_time = time.time()
    
    try:
        # Redact PII from input
        clean_message = redactor.redact_text(request.message)
        
        # Generate session ID if not provided
        session_id = request.session_id or str(uuid.uuid4())
        
        # Prepare context
        context = {
            "session_id": session_id,
            "state": request.state,
            "city": request.city,
            "user_type": request.user_type,
            **request.context
        }
        
        # Process query through MCP server
        result = await mcp_server.process_chat_query(clean_message, context)
        
        total_time = (time.time() - start_time) * 1000
        
        return ChatResponse(
            response=result["llm_response"]["response"],
            citations=result["llm_response"]["citations"],
            next_steps=result["llm_response"]["next_steps"],
            confidence=result["llm_response"]["confidence"],
            should_escalate=result["llm_response"]["should_escalate"],
            session_id=session_id,
            processing_time_ms=total_time
        )
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to process chat request: {str(e)}"
        )

@router.post("/chat/escalate")
async def escalate_chat(
    session_id: str,
    reason: Optional[str] = "User requested human assistance",
    token: str = Depends(get_bearer_token)
):
    """Escalate conversation to human advisor"""
    
    result = await mcp_server.execute_tool("escalate_to_human", {
        "session_id": session_id,
        "reason": reason
    })
    
    if result["success"]:
        return result["result"]
    else:
        raise HTTPException(status_code=500, detail=result["error"])
```

### 12. Create app/api/endpoints/eligibility.py
```python
from fastapi import APIRouter, HTTPException, Depends
from app.models.request_models import EligibilityRequest
from app.models.response_models import EligibilityResponse
from app.tools.eligibility_tool import eligibility_calculator
from app.api.endpoints.chat import get_bearer_token

router = APIRouter()

@router.post("/eligibility", response_model=EligibilityResponse)
async def calculate_eligibility(
    request: EligibilityRequest,
    token: str = Depends(get_bearer_token)
):
    """
    Calculate home loan eligibility
    
    Example:
    {
        "monthly_income": 120000,
        "existing_obligations": 20000,
        "interest_rate": 8.6,
        "tenure_years": 20,
        "foir_cap": 40
    }
    """
    
    try:
        result = eligibility_calculator.calculate_eligibility(
            monthly_income=request.monthly_income,
            existing_obligations=request.existing_obligations,
            interest_rate=request.interest_rate,
            tenure_years=request.tenure_years,
            foir_cap=request.foir_cap
        )
        
        return EligibilityResponse(**result)
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to calculate eligibility: {str(e)}"
        )

@router.get("/eligibility/quick")
async def quick_eligibility_check(
    income: float,
    rate: float = 8.5,
    years: int = 20,
    token: str = Depends(get_bearer_token)
):
    """Quick eligibility check with minimal parameters"""
    
    result = eligibility_calculator.calculate_eligibility(
        monthly_income=income,
        existing_obligations=0,
        interest_rate=rate,
        tenure_years=years
    )
    
    return {
        "max_loan_amount": result["estimated_loan_amount"],
        "max_emi": result["max_emi"],
        "status": result["eligibility_status"]
    }
```

### 13. Create app/api/endpoints/feedback.py
```python
from fastapi import APIRouter, HTTPException, Depends
from app.models.request_models import FeedbackRequest
from app.models.response_models import FeedbackResponse
from app.api.endpoints.chat import get_bearer_token
import logging

router = APIRouter()

# In production, this would connect to a proper database
feedback_store = []

@router.post("/feedback", response_model=FeedbackResponse)
async def submit_feedback(
    request: FeedbackRequest,
    token: str = Depends(get_bearer_token)
):
    """Submit feedback for a chat session"""
    
    try:
        # Store feedback (in production, save to database)
        feedback_entry = {
            "session_id": request.session_id,
            "rating": request.rating,
            "comment": request.comment,
            "category": request.category,
            "timestamp": time.time()
        }
        
        feedback_store.append(feedback_entry)
        
        # Log for analytics
        logging.info(f"Feedback received: {request.session_id} - Rating: {request.rating}")
        
        return FeedbackResponse(
            success=True,
            message="Thank you for your feedback!"
        )
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to submit feedback: {str(e)}"
        )

@router.get("/feedback/stats")
async def get_feedback_stats(token: str = Depends(get_bearer_token)):
    """Get feedback statistics (admin endpoint)"""
    
    if not feedback_store:
        return {"message": "No feedback data available"}
    
    ratings = [f["rating"] for f in feedback_store]
    
    return {
        "total_feedback": len(feedback_store),
        "average_rating": sum(ratings) / len(ratings),
        "rating_distribution": {
            str(i): ratings.count(i) for i in range(1, 6)
        }
    }
```

### 14. Create app/api/endpoints/health.py
```python
from fastapi import APIRouter
import time
import psutil
from app.config import settings
from app.models.response_models import HealthResponse
from app.core.rag_engine import rag_engine

router = APIRouter()

start_time = time.time()

@router.get("/health", response_model=HealthResponse)
async def health_check():
    """Health check endpoint"""
    
    uptime = time.time() - start_time
    
    # Check dependencies
    dependencies = {
        "faiss_index": "healthy" if rag_engine.local_index else "unavailable",
        "documents": f"{len(rag_engine.documents)} loaded" if rag_engine.documents else "none",
        "memory_usage": f"{psutil.virtual_memory().percent}%",
        "cpu_usage": f"{psutil.cpu_percent()}%"
    }
    
    # Add Pinecone status if configured
    if rag_engine.pinecone_index:
        try:
            # Test Pinecone connection
            rag_engine.pinecone_index.describe_index_stats()
            dependencies["pinecone"] = "connected"
        except:
            dependencies["pinecone"] = "error"
    
    return HealthResponse(
        status="healthy",
        version="1.0.0",
        dependencies=dependencies,
        uptime_seconds=uptime
    )

@router.get("/health/detailed")
async def detailed_health():
    """Detailed health information"""
    
    return {
        "service": "AI Loan Support Backend",
        "version": "1.0.0",
        "environment": "development",
        "configuration": {
            "use_local_faiss": settings.USE_LOCAL_FAISS,
            "max_retrieval_docs": settings.MAX_RETRIEVAL_DOCS,
            "gemini_model": settings.GEMINI_MODEL
        },
        "performance": {
            "retrieval_timeout": settings.RETRIEVAL_TIMEOUT,
            "llm_timeout": settings.LLM_TIMEOUT
        }
    }
```

### 15. Create app/main.py
```python
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import time
import logging

from app.config import settings
from app.api.endpoints import chat, eligibility, feedback, health

# Configure logging
logging.basicConfig(level=settings.LOG_LEVEL if hasattr(settings, 'LOG_LEVEL') else 'INFO')
logger = logging.getLogger(__name__)

# Create FastAPI app
app = FastAPI(
    title=settings.PROJECT_NAME,
    version="1.0.0",
    description="AI Customer Support Backend for Loan Company",
    docs_url="/docs",
    redoc_url="/redoc"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify exact origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Request timing middleware
@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response

# Exception handler
@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    logger.error(f"Unhandled exception: {exc}")
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error occurred"}
    )

# Include routers
app.include_router(
    health.router,
    prefix=settings.API_PREFIX,
    tags=["health"]
)

app.include_router(
    chat.router,
    prefix=settings.API_PREFIX,
    tags=["chat"]
)

app.include_router(
    eligibility.router,
    prefix=settings.API_PREFIX,
    tags=["eligibility"]
)

app.include_router(
    feedback.router,
    prefix=settings.API_PREFIX,
    tags=["feedback"]
)

# Root endpoint
@app.get("/")
async def root():
    return {
        "message": "AI Loan Support Backend",
        "version": "1.0.0",
        "docs": "/docs",
        "health": f"{settings.API_PREFIX}/health"
    }

# Startup event
@app.on_event("startup")
async def startup_event():
    logger.info("Starting AI Loan Support Backend...")
    logger.info(f"Using Gemini model: {settings.GEMINI_MODEL}")
    logger.info(f"Local FAISS mode: {settings.USE_LOCAL_FAISS}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=5000,
        reload=True,
        log_level="info"
    )
```

### 16. Create comprehensive test files

**tests/test_chat.py:**
```python
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

headers = {"Authorization": "Bearer dev-token-change-in-production"}

def test_chat_document_query():
    """Test document requirements query for Karnataka salaried"""
    
    response = client.post(
        "/api/v1/chat",
        json={
            "message": "What documents do I need for a ₹75L home loan in Bengaluru? I'm salaried.",
            "state": "Karnataka",
            "city": "Bengaluru",
            "user_type": "salaried"
        },
        headers=headers
    )
    
    assert response.status_code == 200
    data = response.json()
    
    assert "documents" in data["response"].lower()
    assert "karnataka" in data["response"].lower() or "bengaluru" in data["response"].lower()
    assert len(data["citations"]) > 0
    assert len(data["next_steps"]) > 0
    assert data["confidence"] > 0.5

def test_chat_eligibility_query():
    """Test eligibility calculation query"""
    
    response = client.post(
        "/api/v1/chat",
        json={
            "message": "Am I eligible for a home loan with ₹1,20,000 monthly income?",
            "context": {
                "monthly_income": 120000,
                "existing_obligations": 20000
            }
        },
        headers=headers
    )
    
    assert response.status_code == 200
    data = response.json()
    
    assert "eligible" in data["response"].lower()
    assert "₹" in data["response"]  # Should contain rupee amounts

def test_chat_stamp_duty_query():
    """Test stamp duty query for Karnataka"""
    
    response = client.post(
        "/api/v1/chat",
        json={
            "message": "What's the stamp duty for an ₹85L flat in Bangalore?",
            "state": "Karnataka",
            "city": "Bangalore"
        },
        headers=headers
    )
    
    assert response.status_code == 200
    data = response.json()
    
    assert "stamp duty" in data["response"].lower()
    assert "%" in data["response"]  # Should contain percentage
    assert len(data["citations"]) > 0

def test_chat_pii_redaction():
    """Test PII redaction in chat"""
    
    response = client.post(
        "/api/v1/chat",
        json={
            "message": "My PAN is ABCDE1234F and Aadhaar is 1234-5678-9123. What documents do I need?"
        },
        headers=headers
    )
    
    assert response.status_code == 200
    data = response.json()
    
    # Should not contain full PAN or Aadhaar
    assert "ABCDE1234F" not in data["response"]
    assert "1234-5678-9123" not in data["response"]

def test_chat_unauthorized():
    """Test unauthorized access"""
    
    response = client.post(
        "/api/v1/chat",
        json={"message": "Test message"}
    )
    
    assert response.status_code == 401
```

**tests/test_eligibility.py:**
```python
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)
headers = {"Authorization": "Bearer dev-token-change-in-production"}

def test_eligibility_calculation():
    """Test eligibility calculation with valid inputs"""
    
    response = client.post(
        "/api/v1/eligibility",
        json={
            "monthly_income": 120000,
            "existing_obligations": 20000,
            "interest_rate": 8.6,
            "tenure_years": 20,
            "foir_cap": 40
        },
        headers=headers
    )
    
    assert response.status_code == 200
    data = response.json()
    
    assert data["max_emi"] > 0
    assert data["estimated_loan_amount"] > 0
    assert 0 <= data["foir_used"] <= 100
    assert "disclaimer" in data
    assert data["eligibility_status"] in ["Eligible", "Conditionally Eligible", "Not Eligible", "Low Eligibility"]

def test_eligibility_high_obligations():
    """Test eligibility with high existing obligations"""
    
    response = client.post(
        "/api/v1/eligibility",
        json={
            "monthly_income": 50000,
            "existing_obligations": 45000,  # 90% of income
            "interest_rate": 8.5,
            "tenure_years": 20
        },
        headers=headers
    )
    
    assert response.status_code == 200
    data = response.json()
    
    assert data["max_emi"] == 0
    assert data["estimated_loan_amount"] == 0
    assert "Not Eligible" in data["eligibility_status"]

def test_quick_eligibility():
    """Test quick eligibility endpoint"""
    
    response = client.get(
        "/api/v1/eligibility/quick?income=100000&rate=8.5&years=20",
        headers=headers
    )
    
    assert response.status_code == 200
    data = response.json()
    
    assert "max_loan_amount" in data
    assert "max_emi" in data
    assert "status" in data
```

### 17. Create dummy PDF documents

**Create app/data/documents/create_pdfs.py:**
```python
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
import os

def create_karnataka_salaried_docs():
    """Create Karnataka salaried documents PDF"""
    
    doc = SimpleDocTemplate(
        "app/data/documents/karnataka_salaried_docs.pdf",
        pagesize=letter
    )
    
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        spaceAfter=30,
    )
    
    story = []
    
    # Title
    story.append(Paragraph("Karnataka Home Loan Documents - Salaried Applicants", title_style))
    story.append(Spacer(1, 12))
    
    # Content sections
    sections = [
        ("Identity Proof Documents", [
            "PAN Card (mandatory)",
            "Aadhaar Card",
            "Passport (if available)",
            "Voter ID Card",
            "Driving License"
        ]),
        ("Address Proof Documents", [
            "Aadhaar Card",
            "Utility Bills (electricity, water, gas) - last 3 months",
            "Rent Agreement (if rented)",
            "Property documents (if owned)",
            "Bank statements showing address"
        ]),
        ("Income Proof Documents", [
            "Salary slips - last 3 months",
            "Bank statements - last 6 months",
            "Form 16 - last 2 years",
            "Employment certificate/letter",
            "Appointment letter",
            "Increment letters (if any)"
        ]),
        ("Property Documents", [
            "Sale agreement/allotment letter",
            "Property card/Khata extract",
            "Encumbrance certificate",
            "Survey settlement/revenue records",
            "Building plan approval",
            "Possession certificate"
        ]),
        ("Additional Documents", [
            "Passport size photographs - 2 copies",
            "Processing fee cheque",
            "Existing loan statements (if any)",
            "Investment proofs for tax benefits",
            "Co-applicant documents (if applicable)"
        ])
    ]
    
    for section_title, items in sections:
        story.append(Paragraph(section_title, styles['Heading2']))
        story.append(Spacer(1, 6))
        
        for item in items:
            story.append(Paragraph(f"• {item}", styles['Normal']))
        
        story.append(Spacer(1, 12))
    
    # Footer
    story.append(Spacer(1, 24))
    story.append(Paragraph("Source: Karnataka Banking Association & RBI Guidelines 2024", styles['Italic']))
    story.append(Paragraph("Last Updated: September 2024", styles['Italic']))
    
    doc.build(story)

def create_karnataka_stamp_duty():
    """Create Karnataka stamp duty PDF"""
    
    doc = SimpleDocTemplate(
        "app/data/documents/karnataka_stamp_duty.pdf",
        pagesize=letter
    )
    
    styles = getSampleStyleSheet()
    story = []
    
    story.append(Paragraph("Karnataka Stamp Duty and Registration Charges", styles['Title']))
    story.append(Spacer(1, 20))
    
    content = [
        ("Stamp Duty Rates for Residential Properties", [
            "Properties above ₹45 lakhs in BBMP limits: 5%",
            "Properties below ₹45 lakhs in BBMP limits: 3%",
            "Other urban areas: 4%",
            "Rural areas: 3%",
            "Additional 1% for properties above ₹1 crore"
        ]),
        ("Registration Charges", [
            "Registration fee: 1% of property value",
            "Minimum registration fee: ₹1,000",
            "Survey settlement fee: ₹300-₹500",
            "Document writer fee: ₹100-₹200"
        ]),
        ("Additional Charges", [
            "Encumbrance certificate: ₹50 per year",
            "Khata transfer: ₹200-₹500",
            "Property card: ₹50",
            "Legal documentation: ₹5,000-₹15,000"
        ]),
        ("Total Cost Estimation", [
            "For ₹85 lakh property in Bangalore:",
            "Stamp duty (5%): ₹4,25,000",
            "Registration (1%): ₹85,000",
            "Other charges: ₹15,000-₹25,000",
            "Total: ₹5,25,000-₹5,35,000 (approx 6.2%)"
        ])
    ]
    
    for section_title, items in content:
        story.append(Paragraph(section_title, styles['Heading2']))
        story.append(Spacer(1, 8))
        
        for item in items:
            story.append(Paragraph(f"• {item}", styles['Normal']))
        
        story.append(Spacer(1, 12))
    
    story.append(Spacer(1, 20))
    story.append(Paragraph("Source: Karnataka Revenue Department, 2024", styles['Italic']))
    
    doc.build(story)

def create_loan_glossary():
    """Create loan glossary PDF"""
    
    doc = SimpleDocTemplate(
        "app/data/documents/loan_glossary.pdf",
        pagesize=letter
    )
    
    styles = getSampleStyleSheet()
    story = []
    
    story.append(Paragraph("Home Loan Glossary", styles['Title']))
    story.append(Spacer(1, 20))
    
    terms = [
        ("EMI", "Equated Monthly Installment - Fixed monthly payment towards loan"),
        ("FOIR", "Fixed Obligation to Income Ratio - Percentage of income going to debt payments"),
        ("LTV", "Loan to Value Ratio - Loan amount as percentage of property value"),
        ("Processing Fee", "Upfront charges by bank for loan processing (0.5-1% of loan amount)"),
        ("Prepayment", "Paying loan amount before completion of tenure"),
        ("Foreclosure", "Complete repayment of outstanding loan amount"),
        ("Sanction", "Formal approval of loan application by the bank"),
        ("Disbursal", "Actual transfer of loan funds to borrower/seller"),
        ("Moratorium", "Grace period where only interest is paid"),
        ("CIBIL Score", "Credit score ranging from 300-900, higher is better"),
        ("Collateral", "Asset pledged as security for the loan"),
        ("Co-applicant", "Joint applicant who shares loan responsibility")
    ]
    
    for term, definition in terms:
        story.append(Paragraph(f"<b>{term}:</b> {definition}", styles['Normal']))
        story.append(Spacer(1, 8))
    
    doc.build(story)

if __name__ == "__main__":
    os.makedirs("app/data/documents", exist_ok=True)
    
    create_karnataka_salaried_docs()
    create_karnataka_stamp_duty()
    create_loan_glossary()
    
    print("PDF documents created successfully!")
```

### 18. Create Postman Collection

**postman_collection.json:**
```json
{
    "info": {
        "name": "AI Loan Support Backend",
        "description": "Complete API collection for testing the AI loan support backend",
        "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
    },
    "auth": {
        "type": "bearer",
        "bearer": [
            {
                "key": "token",
                "value": "dev-token-change-in-production",
                "type": "string"
            }
        ]
    },
    "variable": [
        {
            "key": "base_url",
            "value": "http://localhost:5000/api/v1",
            "type": "string"
        }
    ],
    "item": [
        {
            "name": "Health Check",
            "request": {
                "method": "GET",
                "header": [],
                "url": {
                    "raw": "{{base_url}}/health",
                    "host": ["{{base_url}}"],
                    "path": ["health"]
                }
            }
        },
        {
            "name": "Chat - Document Query",
            "request": {
                "method": "POST",
                "header": [
                    {
                        "key": "Content-Type",
                        "value": "application/json"
                    }
                ],
                "body": {
                    "mode": "raw",
                    "raw": "{\n    \"message\": \"What documents do I need for a ₹75L home loan in Bengaluru? I'm salaried.\",\n    \"state\": \"Karnataka\",\n    \"city\": \"Bengaluru\",\n    \"user_type\": \"salaried\"\n}"
                },
                "url": {
                    "raw": "{{base_url}}/chat",
                    "host": ["{{base_url}}"],
                    "path": ["chat"]
                }
            }
        },
        {
            "name": "Chat - Eligibility Query",
            "request": {
                "method": "POST",
                "header": [
                    {
                        "key": "Content-Type",
                        "value": "application/json"
                    }
                ],
                "body": {
                    "mode": "raw",
                    "raw": "{\n    \"message\": \"Am I eligible for a home loan with ₹1,20,000 monthly income?\",\n    \"context\": {\n        \"monthly_income\": 120000,\n        \"existing_obligations\": 20000\n    }\n}"
                },
                "url": {
                    "raw": "{{base_url}}/chat",
                    "host": ["{{base_url}}"],
                    "path": ["chat"]
                }
            }
        },
        {
            "name": "Chat - Stamp Duty Query",
            "request": {
                "method": "POST",
                "header": [
                    {
                        "key": "Content-Type",
                        "value": "application/json"
                    }
                ],
                "body": {
                    "mode": "raw",
                    "raw": "{\n    \"message\": \"What's the stamp duty for an ₹85L flat in Bangalore?\",\n    \"state\": \"Karnataka\",\n    \"city\": \"Bangalore\"\n}"
                },
                "url": {
                    "raw": "{{base_url}}/chat",
                    "host": ["{{base_url}}"],
                    "path": ["chat"]
                }
            }
        },
        {
            "name": "Eligibility Calculation",
            "request": {
                "method": "POST",
                "header": [
                    {
                        "key": "Content-Type",
                        "value": "application/json"
                    }
                ],
                "body": {
                    "mode": "raw",
                    "raw": "{\n    \"monthly_income\": 120000,\n    \"existing_obligations\": 20000,\n    \"interest_rate\": 8.6,\n    \"tenure_years\": 20,\n    \"foir_cap\": 40\n}"
                },
                "url": {
                    "raw": "{{base_url}}/eligibility",
                    "host": ["{{base_url}}"],
                    "path": ["eligibility"]
                }
            }
        },
        {
            "name": "Quick Eligibility",
            "request": {
                "method": "GET",
                "header": [],
                "url": {
                    "raw": "{{base_url}}/eligibility/quick?income=100000&rate=8.5&years=20",
                    "host": ["{{base_url}}"],
                    "path": ["eligibility", "quick"],
                    "query": [
                        {"key": "income", "value": "100000"},
                        {"key": "rate", "value": "8.5"},
                        {"key": "years", "value": "20"}
                    ]
                }
            }
        },
        {
            "name": "Submit Feedback",
            "request": {
                "method": "POST",
                "header": [
                    {
                        "key": "Content-Type",
                        "value": "application/json"
                    }
                ],
                "body": {
                    "mode": "raw",
                    "raw": "{\n    \"session_id\": \"test_session_123\",\n    \"rating\": 5,\n    \"comment\": \"Very helpful and accurate information!\",\n    \"category\": \"helpful\"\n}"
                },
                "url": {
                    "raw": "{{base_url}}/feedback",
                    "host": ["{{base_url}}"],
                    "path": ["feedback"]
                }
            }
        }
    ]
}
```

### 19. SETUP INSTRUCTIONS

1. **Copy this entire prompt into a new Replit project**

2. **Install dependencies:**
```bash
pip install -r requirements.txt
```

3. **Set up environment variables:**
Copy `.env.example` to `.env` and fill in your API keys:
```bash
cp .env.example .env
# Edit .env with your actual API keys
```

4. **Create PDF documents:**
```bash
python app/data/documents/create_pdfs.py
```

5. **Run the application:**
```bash
python app/main.py
```

6. **Test the APIs:**
- Health check: GET `http://localhost:5000/api/v1/health`
- Chat: POST `http://localhost:5000/api/v1/chat`
- Eligibility: POST `http://localhost:5000/api/v1/eligibility`

7. **Run tests:**
```bash
pytest tests/ -v
```

8. **Import Postman collection:**
Import `postman_collection.json` into Postman for easy API testing.

### 20. KEY FEATURES DELIVERED

✅ **FastAPI Backend** with modular structure
✅ **MCP Server** for tool orchestration
✅ **Vector Database** (FAISS local + Pinecone ready)
✅ **Gemini LLM Integration** with citations
✅ **PII Redaction** (PAN/Aadhaar masking)
✅ **Eligibility Calculator** with FOIR logic
✅ **State-specific responses** (Karnataka focus)
✅ **Comprehensive test cases**
✅ **API documentation** (FastAPI auto-docs)
✅ **Postman collection** for testing
✅ **Sample PDF documents** with real content
✅ **Channel-agnostic design** (ready for voice/WhatsApp)
✅ **Performance monitoring** and metrics
✅ **Security** with bearer token authentication

### 21. EXAMPLE API USAGE

**Chat Query Example:**
```bash
curl -X POST "http://localhost:5000/api/v1/chat" \
-H "Authorization: Bearer dev-token-change-in-production" \
-H "Content-Type: application/json" \
-d '{
    "message": "What documents do I need for a ₹75L home loan in Bengaluru? I am salaried.",
    "state": "Karnataka",
    "city": "Bengaluru", 
    "user_type": "salaried"
}'
```

This will return a comprehensive response with document requirements, citations, and next steps!

---

**Copy the entire content above into a Replit project to create your complete AI Loan Support Backend!**